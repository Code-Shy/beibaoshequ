# 嵌入式笔记

## 串口

### 数据接收

　　当接收到从电脑发过来的数据，把接收到的数据保存在 USART_RX_BUF 中，同时在接收 状态寄存器（USART_RX_STA）中计数接收到的有效数据个数，当收到回车（回车的表示由 2 个字节组成：0X0D 和 0X0A）的**第一个字节 0X0D** 时，计数器将不再增加，**等待 0X0A** 的到来， 而如果 0X0A 没有来到，则认为这次接收失败，重新开始下一次接收。如果顺利接收到 0X0A， 则标记 USART_RX_STA 的第 15 位，这样完成一次接收，并等待该位被其他程序清除，从而开 始下一次的接收，而如果迟迟没有收到0X0D，那么在接收数据超过USART_REC_LEN的时候， STM32F4 开发指南(库函数版) ALIENTEK 探索者 STM32F407 开发板教程 146 则会丢弃前面的数据，重新接收。

### USART_RX_STA

### ![image-20220322163334481](D:\嵌入式\笔记.assets\image-20220322163334481.png)

即指一个单位时间内传输符号的个数



### EN_USART1_RX 和 USART_REC_LEN 

都是在 usart.h 文件里面定义的，当需要使用串口接收的时候，我们只要在 usart.h 里面设置 EN_USART1_RX 为 1 就可以了







## IO作为输出

### 跑马灯

- [STM32输入输出模式理解-OpenEdv-开源电子网](http://www.openedv.com/posts/list/32730.htm)
- **在配置 STM32 外设的时候，任何时候都要先使能该外设的时钟！**
- GPIO 是挂载在 AHB1 总线上的外设，在固件库中对挂载在 AHB1 总线上的外设 时钟使能是通过函数 RCC_AHB1PeriphClockCmd ()来实现的
- 编译结果里面的几个数据的意义： 
  - Code：表示程序所占用 FLASH 的大小（FLASH）。 
  - RO-data：即 Read Only-data，表示程序定义的常量（FLASH）。
  - RW-data：即 Read Write-data，表示已被初始化的变量（SRAM） 
  - ZI-data：即 Zero Init-data，表示未被初始化的变量(SRAM)

### 蜂鸣器

- 有源不是指电源的“源”，而是指有没有自带震荡电路，有源蜂鸣器自带了震荡电路， 一通电就会发声；无源蜂鸣器则没有自带震荡电路，必须外部提供 2~5Khz 左右的方波驱动， 才能发声。



## IO作为输入

### 按键输入实验

- KEY0、KEY1 和 KEY2 是低电平有效的，而 KEY_UP 是高电平有效 的，并且外部都没有上下拉电阻，所以，需要在 STM32F4 内部设置上下拉。

## 串口通信实验

- 串口 1 对应着芯片引脚 PA9,PA10

- 对于复用功能的 IO，我们首先要使能 GPIO 时钟， 然后使能相应的外设时钟，同时要把 GPIO 模式设置为复用。

- STM32F4 的发送与接收是通过数据寄存器 USART_DR 来实现的，这是一个双寄存器，包 含了 TDR 和 RDR。

- 串口的状态可以通过状态寄存器 USART_SR 读取。



## 外部中断实验

- STM32F4 的每个 IO 都可以作为 外部中断的中断输入口，这点也是 STM32F4 的强大之处。
- TM32F407 的 22 个外部中断为：
  - EXTI 线 0~15：对应外部 IO 口的输入中断。 
  - EXTI 线 16：连接到 PVD 输出。 
  - EXTI 线 17：连接到 RTC 闹钟事件。 
  - EXTI 线 18：连接到 USB OTG FS 唤醒事件。
  -  EXTI 线 19：连接到以太网唤醒事件。 
  - EXTI 线 20：连接到 USB OTG HS(在 FS 中配置)唤醒事件。 EXTI 线 21：连接到 RTC 入侵和时间戳事件。 
  - EXTI 线 22：连接到 RTC 唤醒事件。

- 从上面可以看出，STM32F4 供 IO 口使用的中断线只有 16 个，但是 STM32F4 的 IO 口却 远远不止 16 个，那么 STM32F4 是怎么把 16 个中断线和 IO 口一一对应起来的呢？
  - 于是 STM32 就这样设计，GPIO 的管脚GPIOx.0~GPIOx.15(x=A,B,C,D,E，F,G,H,I)分别对应中断线 0~15。这 样每个中断线对应了最多 9 个 IO 口，以线 0 为例：它对应了 GPIOA.0、GPIOB.0、GPIOC.0、 GPIOD.0、GPIOE.0、GPIOF.0、GPIOG.0,GPIOH.0,GPIOI.0。而



![image-20220412150036792](笔记.assets/image-20220412150036792.png)

![image-20220412150844784](笔记.assets/image-20220412150844784.png)



- KEY_UP 按键是高电平有效的，而 KEY0、KEY1 和 KEY2 是低 电平有效的，所以我们设置 KEY_UP 为上升沿触发中断，而 KEY0、KEY1 和 KEY2 则设置为 下降沿触发。
- STM32F4的外部中断 0~4 都有单独的中断服务函数，但是从 5 开始， 他们就没有单独的服务函数了，而是多个中断共用一个服务函数，比如外部中断 5~9 的中断服 务函数为：void EXTI9_5_IRQHandler(void)，类似的，void EXTI15_10_IRQHandler(void)就是 外部中断 10~15 的中断服务函数。



## 独立看门狗（IWDG）实验

- 设置好看门狗的分频系数 prer 和重装载值就可以知道看门狗的喂狗时间（也就是看门狗溢 出时间），该时间的计算方式为：

   $Tout=((4×2^{prer} ) ×rlr) /40$

  其中 **Tout** 为看门狗溢出时间（单位为 ms）；**prer** 为看门狗时钟预分频值（IWDG_PR 值）， STM32F4 开发指南(库函数版) ALIENTEK 探索者 STM32F407 开发板教程 199 范围为 0~7；**rlr** 为看门狗的重装载值（IWDG_RLR 的值）；

- 注意 IWDG 在一旦启用，就不能再被关闭！



## 定时器中断实验

1. STM32F407的通用 **TIMx (TIM2~TIM5 和 TIM9~TIM14)**定时器功能：

   - 16位/32位向上、向下、向上/向下自动装载计数器；

   - 16位可编程(可以实时修改)预分频器；

   - 4个独立通道：

      A．输入捕获

      B．输出比较

      C．PWM输出

      D．单脉冲模式输出

   - 可实现定时器互连（用1个定时器控制另外一个定时器）的同步电路。

   - 如下事件发生时产生全局中断：

      A．更新：计数器向上溢出/向下溢出，计数器初始化

      B．触发事件(计数器启动、停止、初始化或者由内部/外部

     ​     触发计数)

      C．输入捕获

      D．输出比较

2. 因此，TIM3 的时 钟为 84M，再根据我们设计的 arr 和 psc 的值，就可以计算中断时间了。计算公式如下： 

   $Tout= ((arr+1)*(psc+1))/Tclk$；

    其中： 

   - Tclk：TIM3 的输入时钟频率（单位为 Mhz）。 
   - Tout：TIM3 溢出时间（单位为 us）。 

3. 除此之外，也可以通过配置预分频器，来获取想要的定时器时钟频率。依然以上边的TIM1为例，如果我们想获取一个精确的1ms中断，如果不分频，72MHz的时钟对应每周期1/72us，十分不利于计算。这时候使用预分频器将其72分频后为1MHz，每周期1us，1000个计时周期即为1ms，这样既便于计算，定时也更加精确。

   预分频器的工作的工作原理是，定时器时钟源每tick一次，**预分频器计数器**值+1，直到达到预分频器的设定值，然后再tick一次后计数器归零，同时，**CNT计数器**值+1。

4. Tout= ((arr+1)*(psc+1))/Tclk：

   其中arr为你重装的值，

   psc是预分频计时器的值，

   Tclk是时钟频率

   (psc+1))/Tclk*1是计算的计数器 减少/增加 一个数所用的时间；

   那么(psc+1))/Tclk*(arr+1)就是一次定时器的时间:

   然后继续重装arr再次计数，计时：

   就构成一个循环；

   自己补充：（psc+1和arr+1原因 假设我想让arr自动重装载值为 第5000次 溢出，而实际计数则是从0开始到4999结束刚好5000个数，但是带入公式计算如果写4999则少了一次，所以要加一，psc要加一则是因为数据手册上的硬性规定（具体为啥不知道。。有大神知道可以解释一下哈 感谢！）

## PWM输出实验

- 脉冲宽度调制(PWM)，是英文“Pulse Width Modulation”的缩写，简称脉宽调制

- 改变 CCRx 的值，就可以改变 PWM 输出的占空比，改变 ARR 的值，就可以改变 PWM 输出的 频率
- **占空比**是指在一个脉冲循环内，通电时间相对于总时间所占的比例。



## 输入捕获实验





## TFTLCD显示实验

![image-20220418223425346](笔记.assets/image-20220418223425346.png)



**FSMC**

​    FSMC(Flexible Static Memory Controller，可变静态存储控制器)是STM32系列中内部集成256 KB以上FlaSh，后缀为xC、xD和xE的高存储密度微控制器特有的存储控制机制。之所以称为“可变”，是由于通过对[特殊功能寄存器](https://baike.baidu.com/item/特殊功能寄存器)的设置，FSMC能够根据不同的外部[存储器](https://baike.baidu.com/item/存储器)类型，发出相应的数据/地址/[控制信号](https://baike.baidu.com/item/控制信号)类型以匹配信号的速度，从而使得STM32系列微控制器不仅能够应用各种不同类型、不同速度的外部[静态存储器](https://baike.baidu.com/item/静态存储器)，而且能够在不增加外部器件的情况下同时扩展多种不同类型的静态存储器，满足系统设计对存储容量、产品体积以及成本的综合要求。
